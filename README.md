# neo-push

âš  Using **embedded** alpha branch here https://github.com/danstarns/graphql/tree/alpha. The embedded branch is ahead in terms of;

1. OGM(Object Graph Mapper)
2. @auth bind
3. Dates & @timestamps
4. @autogenerated
5. various fixes; (skip-limit-coercion)
6. @readonly

Example blog site built with `@neo4j/graphql` & React.js. This application showcases features of `@neo4j/graphql` such as;

1. Nested Mutations
2. @auth directive
3. OGM(Object Graph Mapper)

There are only two custom resolvers in the server; sign up plus sign in. The lack of custom logic is showcasing how quickly developers can build, both powerful and secure, applications ontop of Neo4j. Its worth nothing this entire application contains zero 'raw' cypher. All interaction's with the database are done through the generated GraphQL Schema via either the OGM or Apollo Server.

![overview](assets/overview.gif)
![arrows of data](assets/arrows.png)
**Diagram from https://arrows.app/**

```graphql
type User @timestamps {
    id: ID! @autogenerated @readonly
    email: String!
    password: String!
    createdBlogs: [Blog] @relationship(type: "HAS_BLOG", direction: "OUT")
    authorsBlogs: [Blog] @relationship(type: "CAN_POST", direction: "OUT")
}

type Blog @timestamps {
    id: ID! @autogenerated @readonly
    name: String!
    creator: User @relationship(type: "HAS_BLOG", direction: "IN") @readonly
    authors: [User] @relationship(type: "CAN_POST", direction: "IN")
    posts: [Post] @relationship(type: "HAS_POST", direction: "OUT")
}

type Post @timestamps {
    id: ID! @autogenerated @readonly
    title: String!
    content: String!
    blog: Blog @relationship(type: "HAS_POST", direction: "IN")
    comments: [Comment] @relationship(type: "HAS_COMMENT", direction: "OUT")
    author: User @relationship(type: "WROTE", direction: "IN") @readonly
}

type Comment @timestamps {
    id: ID! @autogenerated @readonly
    author: User @relationship(type: "COMMENTED", direction: "IN") @readonly
    content: String!
    post: Post @relationship(type: "HAS_COMMENT", direction: "IN")
}
```

> Schema above simplified for clarity.

## Getting Started

If you want to run this Blog locally follow the steps below. When it comes to [Configure environment variables](#how-to-configure-environment-variables-?) you will need a [running Neo4j instance](#how-to-start-neo4j-?) to point to.

### How to configure environment variables ?

Each package contains a `./env.example` file. Copy this file, to the same directory, at `./.env` and adjust configuration to suit your local machine although the defaults may be fine.

### How to start Neo4j ?

There are many ways to get started with neo4j such as; [Neo4j Sandbox](https://neo4j.com/sandbox/), [Neo4j Desktop](https://neo4j.com/developer/neo4j-desktop/) or [Docker](https://neo4j.com/developer/docker/).

### Steps

Clone the repo;

```
$ git clone git@github.com:danstarns/neo-push.git
```

Enter the repo and install deps(lerna will install client and server);

```
$ cd neo-push && npm ci
```

=> [Configure environment variables](#how-to-configure-environment-variables) <=

Run the client on;

```
$ npm run client:dev
```

Run Seeder on;

```
$ npm run seed
```

> Checkout the seeder its using the OGM

**Once seeded used the default credentials to log in**

1. Email: admin@admin.com
2. Password: password

Run the server on;

```
$ npm run server:dev
```

Navigate to http://localhost:4000 and sign up!

![sign up image](assets/sign-up-screenshot.jpg)

## Authentication

This application has two custom resolvers; sign in and sign up. In the resolvers we return a [JWT](https://jwt.io/). This JWT is stored in local storage on the client. The contents of the JWT is something like;

```
{
    "sub": "1234-4321-abcd-dcba", # user.id
    "iat": { ... }
}
```

the `.sub` property is the users id. We use `JWT_SECRET` env var on the sever to configure the secret, this happens to be the same env `@neo4j/graphql` looks at too.

> Note to keep things simple... This application has no JWT expiry or refreshing mechanism. Patterns you would implement outside of `@neo4j/graphql` so we deemed it less important in this showcase.

When the client is making a request to server we attach the JWT in the `authorization` header of the request, the same header `@neo4j/graphql` looks at.

Thats all we need for authentication & more on authorization in the following sections.

## Users

At the core of the app but to keep things simple the UI doesn't have any profile page ect ect.

### Type Definitions

```graphql
type User @timestamps {
    id: ID! @autogenerated @readonly
    email: String!
    password: String!
    createdBlogs: [Blog] @relationship(type: "HAS_BLOG", direction: "OUT")
    authorsBlogs: [Blog] @relationship(type: "CAN_POST", direction: "OUT")
}

extend type User {
    password: String! @readonly
}

extend type User
    @auth(
        rules: [
            { operations: ["read", "create"], isAuthenticated: false }
            { operations: ["connect"], isAuthenticated: true }
            {
                operations: ["update"]
                allow: { id: "sub" }
                bind: { id: "sub" }
            }
            { operations: ["delete"], allow: { id: "sub" } }
            {
                operations: ["disconnect"]
                allow: {
                    OR: [
                        { id: "sub" }
                        {
                            createdBlogs: {
                                OR: [
                                    { creator: { id: "sub" } }
                                    { authors: { id: "sub" } }
                                ]
                            }
                        }
                        {
                            authorsBlogs: {
                                OR: [
                                    { creator: { id: "sub" } }
                                    { authors: { id: "sub" } }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    )
```

### Extend

Using extend above we can separate what gets used in the API and what gets used in the OGM. Considering its our own code calling the OGM we can ignore auth. Above we are making the password `@readonly` to API users meaning no one can edit passwords, something that should to be hashed in a custom resolver, while allowing the edits in the OGM.

Before augmenting our schemas(API & OGM) we filter the extension for the OGM version;

```ts
// without auth and extensions for seeder and custom logic
const OGM = makeAugmentedSchema({
    typeDefs: typeDefs.reduce(
        (res: DocumentNode, type) => {
            const filtered = type.definitions.filter(
                (x) => !x.kind.includes("Extension")
            );

            return {
                ...res,
                definitions: [...res.definitions, ...filtered],
            };
        },
        {
            kind: "Document",
            definitions: [],
        }
    ),
});

// with auth and extensions for server
const API = makeAugmentedSchema({
    typeDefs,
    resolvers,
});

const server: ApolloServer = new ApolloServer({
    schema: API.schema,
});
```

To protect users passwords for unwanted snoopers we add field resolver on `User.password` to blank it out for non admins.

```ts
export const resolvers = {
    Mutation: {
        signUp,
        signIn,
    },
    User: {
        password: (root, _args, context: Context) => {
            if (!context.adminOverride) {
                return "";
            }

            return root.password;
        },
    },
};
```

If we want access to the user password, as in sign in mutation, we can manually inject `context.adminOverride`.

### Authorization

Here some of the auth rules are explained.

#### read and create

```
{ operations: ["read", "create"], isAuthenticated: false }
```

Here is stating that all users even unauthenticated can read a user, for example showing the author of a post. Plus unauthenticated users can create a user such as singing up.

#### connect

```
{ operations: ["connect"], isAuthenticated: true }
```

Here is stating that all authenticated users can create connections to a user, for example a user assigning another as an author of a blog.

#### update

```
{
    operations: ["update"]
    allow: { id: "sub" }
    bind: { id: "sub" }
}
```

Here is using both the `allow` and `bind` features in a new way. Using `allow` we are stating that users can only match and update nodes where the `user.id` property is equal to the JWT`.sub` property meaning users can only update themselves. The `bind` usage here is stating once you edit the user make sure that the `user.id` value is bound to the JWT`.sub` property meaning users cannot change there id.

#### delete

```
{ operations: ["delete"], allow: { id: "sub" } }
```

Here only the user themselves can delete themselves.

#### disconnect

```
{
    operations: ["disconnect"]
    allow: {
        OR: [
            { id: "sub" }
            {
                createdBlogs: {
                    OR: [
                        { creator: { id: "sub" } }
                        { authors: { id: "sub" } }
                    ]
                }
            }
            {
                authorsBlogs: {
                    OR: [
                        { creator: { id: "sub" } }
                        { authors: { id: "sub" } }
                    ]
                }
            }
        ]
    }
}
```

Here we are using complex relationship filtering to ensure that only; the user themselves, and any author or creator, in the related blogs, can disconnect from a user. This allows blog creators and authors to delete user comments on posts and lets the creator of a blog to revoke a users author rights.

## Blogs

Before you can create a post you must create a blog. Users can have many blogs with many post. Each blog can have an array of authors, whom can post to the blog.

### Type Definitions

```graphql
type Blog @timestamps {
    id: ID! @autogenerated @readonly
    name: String!
    creator: User @relationship(type: "HAS_BLOG", direction: "IN") @readonly
    authors: [User] @relationship(type: "CAN_POST", direction: "IN")
    posts: [Post] @relationship(type: "HAS_POST", direction: "OUT")
    isCreator: Boolean
        @cypher(
            statement: """
            OPTIONAL MATCH (this)<-[:HAS_BLOG]-(creator:User {id: $jwt.sub})
            WITH creator IS NOT NULL AS isCreator
            RETURN isCreator
            """
        )
    isAuthor: Boolean
        @cypher(
            statement: """
            OPTIONAL MATCH (this)<-[:CAN_POST]-(author:User {id: $jwt.sub})
            WITH author IS NOT NULL AS isAuthor
            RETURN isAuthor
            """
        )
}

extend type Blog
    @auth(
        rules: [
            { operations: ["create"], bind: { creator: { id: "sub" } } }
            { operations: ["read"], isAuthenticated: false }
            {
                operations: ["update"]
                allow: { creator: { id: "sub" } }
                bind: { creator: { id: "sub" } }
            }
            {
                operations: ["connect"]
                allow: {
                    OR: [{ creator: { id: "sub" } }, { authors: { id: "sub" } }]
                }
            }
            {
                operations: ["disconnect"]
                allow: {
                    OR: [
                        { creator: { id: "sub" } }
                        { authors: { id: "sub" } }
                        { posts: { author: { id: "sub" } } }
                    ]
                }
            }
            { operations: ["delete"], allow: { creator: { id: "sub" } } }
        ]
    )
```

### @cypher

In the typeDefs above you will notice two `@cypher` directives being used; `isCreator` and `isAuthor` this custom cypher returns a boolean and makes the client side cleaner. If noticed there are two 'global' params in the `@cypher` directive; `this` being the currently resolved node & `jwt` being the decoded JWT.

### Authorization

Here some of the auth rules are explained.

#### create

```
{ operations: ["create"], bind: { creator: { id: "sub" } } }
```

Here we are binding the `creator.id` property of a blog to the logged in user, this implies that only authenticated users can create blogs.

#### read

```
{ operations: ["read"], isAuthenticated: false }
```

Here un-Authenticated users can read blogs.

#### update

```
{
    operations: ["update"]
    allow: { creator: { id: "sub" } }
    bind: { creator: { id: "sub" } }
}
```

Only the creator can edit a blog and they cannot point the creator to someone else.

#### connect

```
{
    operations: ["connect"]
    allow: {
        OR: [
            { creator: { id: "sub" } }
            { authors: { id: "sub" } }
        ]
    }
}
```

Both creators and assigned authors of a blog can connect to it. This means creators and authors can connect posts to the blog.

#### disconnect

```
{
    operations: ["disconnect"]
    allow: {
        OR: [
            { creator: { id: "sub" } }
            { authors: { id: "sub" } }
            { posts: { author: { id: "sub" } } }
        ]
    }
}
```

Creators & authors of the blog can disconnect from it. This allows them to delete there own posts.

#### delete

```
{ operations: ["delete"], allow: { creator: { id: "sub" } } }
```

Only the creators of a blog can delete it.

### Dashboard

Once logged in users are directed to the dashboard page;

![dashboard](assets/dashboard.jpg)

```graphql
query myBlogs($id: ID, $skip: Int, $limit: Int, $hasNextBlogsSkip: Int) {
    myBlogs: Blogs(
        where: { OR: [{ creator: { id: $id } }, { authors: { id: $id } }] }
        options: { limit: $limit, skip: $skip, sort: createdAt_DESC }
    ) {
        id
        name
        creator {
            id
            email
        }
        createdAt
    }
    hasNextBlogs: Blogs(
        where: { OR: [{ creator: { id: $id } }, { authors: { id: $id } }] }
        options: { limit: 1, skip: $hasNextBlogsSkip, sort: createdAt_DESC }
    ) {
        id
        createdAt
    }
}
```

### Pagination

âš  Page info such as Relay spec is not supported in the current version of `@neo4j/graphql` so with the **My Blogs** and **Recently Updated Blogs** we query twice asking for the next item, to determine if there is a next page. Using this technique we can paginate the blog lists.

> Image showing pagination with limit of 1, in the app its default to 10.

> ![blogs pagination](assets/blog-pagination.gif)

### Create Blog

From the dashboard you can create a blog.

![create blog gif](assets/create-blog.gif)

```graphql
mutation($name: String!, $sub: ID) {
    createBlogs(
        input: [{ name: $name, creator: { connect: { where: { id: $sub } } } }]
    ) {
        id
        name
        createdAt
    }
}
```

### Edit Blog

If your the creator of a blog you can edit its name.

![edit blog gif](assets/edit-blog.gif)

```graphql
mutation editBlog($id: ID, $name: String) {
    updateBlogs(where: { id: $id }, update: { name: $name }) {
        id
    }
}
```

### Assign Author

If you are the creator of a blog you can assign other users as an author. You can also revoke too!

![assign blog author gif](assets/assign-blog-author.gif)

```graphql
mutation assignBlogAuthor($blog: ID, $authorEmail: String) {
    updateBlogs(
        where: { id: $blog }
        connect: { authors: { where: { email: $authorEmail } } }
    ) {
        authors {
            email
        }
    }
}
```

```graphql
mutation revokeBlogAuthor($blog: ID, $authorEmail: String) {
    updateBlogs(
        where: { id: $blog }
        disconnect: { authors: { where: { email: $authorEmail } } }
    ) {
        authors {
            email
        }
    }
}
```

### Delete Blog

If you are the creator of a blog you can delete it.

![delete blog gif](assets/delete-blog.gif)

```graphql
mutation deleteBlog($id: ID) {
    deleteComments(where: { post: { blog: { id: $id } } }) {
        nodesDeleted
    }
    deletePosts(where: { blog: { id: $id } }) {
        nodesDeleted
    }
    deleteBlogs(where: { id: $id }) {
        nodesDeleted
    }
}
```

## Posts

Users can have many posts with many comments. Blog creators and authors can edit the post. Blog creators and authors of the post can delete it.

### Type Definitions

```graphql
type Post @timestamps {
    id: ID! @autogenerated @readonly
    title: String!
    content: String!
    blog: Blog @relationship(type: "HAS_POST", direction: "IN")
    comments: [Comment] @relationship(type: "HAS_COMMENT", direction: "OUT")
    author: User @relationship(type: "WROTE", direction: "IN") @readonly
    canEdit: Boolean
        @cypher(
            statement: """
            OPTIONAL MATCH (this)<-[:WROTE]-(author:User {id: $jwt.sub})
            OPTIONAL MATCH (this)<-[:HAS_POST]-(blog:Blog)
            OPTIONAL MATCH (blog)<-[:HAS_BLOG]-(blogCreator:User {id: $jwt.sub})
            OPTIONAL MATCH (blog)<-[:CAN_POST]-(blogAuthors:User {id: $jwt.sub})
            WITH (
                (author IS NOT NULL) OR
                (blogCreator IS NOT NULL) OR
                (blogAuthors IS NOT NULL)
            ) AS canEdit
            RETURN canEdit
            """
        )
    canDelete: Boolean
        @cypher(
            statement: """
            OPTIONAL MATCH (this)<-[:WROTE]-(author:User {id: $jwt.sub})
            OPTIONAL MATCH (this)<-[:HAS_POST]-(blog:Blog)
            OPTIONAL MATCH (blog)<-[:HAS_BLOG]-(blogCreator:User {id: $jwt.sub})
            WITH (
                (author IS NOT NULL) OR
                (blogCreator IS NOT NULL)
            ) AS canDelete
            RETURN canDelete
            """
        )
}

extend type Post
    @auth(
        rules: [
            { operations: ["create"], bind: { author: { id: "sub" } } }
            { operations: ["read"], isAuthenticated: false }
            {
                operations: ["update"]
                allow: {
                    OR: [
                        { author: { id: "sub" } }
                        {
                            blog: {
                                OR: [
                                    { creator: { id: "sub" } }
                                    { authors: { id: "sub" } }
                                ]
                            }
                        }
                    ]
                }
            }
            { operations: ["connect"], isAuthenticated: true }
            {
                operations: ["delete", "disconnect"]
                allow: {
                    OR: [
                        { author: { id: "sub" } }
                        { blog: { creator: { id: "sub" } } }
                    ]
                }
            }
        ]
    )
```

### Authorization

Here some of the auth rules are explained.

#### create

```
{ operations: ["create"], bind: { author: { id: "sub" } } }
```

Here we are ensuring that the author of the post is the logged in user. Meaning users cannot assign posts to over users.

#### read

```
{ operations: ["read"], isAuthenticated: false }
```

Anyone can read posts

#### update

```
{
    operations: ["update"]
    allow: {
        OR: [
            { author: { id: "sub" } }
            {
                blog: {
                    OR: [
                        { creator: { id: "sub" } }
                        { authors: { id: "sub" } }
                    ]
                }
            }
        ]
    }
}
```

Here authors of the post, blog creators or authors can edit the post.

#### connect

```
{ operations: ["connect"], isAuthenticated: true }
```

Here only authenticated users can connect to a post such as creating a comment.

#### delete and disconnect

```
{
    operations: ["delete", "disconnect"]
    allow: {
        OR: [
            { author: { id: "sub" } }
            { blog: { creator: { id: "sub" } } }
        ]
    }
}
```

Here only post authors or blog creators and delete disconnect the post.

### Create Post

Once you have a blog. Either the creator or authors can create a post.

![create post gif](assets/create-post.gif)

> Posts support markdown

```graphql
mutation createPost($title: String!, $content: String!, $user: ID, $blog: ID) {
    createPosts(
        input: [
            {
                title: $title
                content: $content
                blog: { connect: { where: { id: $blog } } }
                author: { connect: { where: { id: $user } } }
            }
        ]
    ) {
        id
    }
}
```

### Edit Post

Authors and creators can edit posts belonging to the blog.

![edit post gif](assets/edit-post.gif)

```graphql
mutation editPost($id: ID, $content: String, $title: String) {
    updatePosts(
        where: { id: $id }
        update: { content: $content, title: $title }
    ) {
        id
    }
}
```

### Delete Post

Creators of the blog and authors of the post can delete.

![delete post gif](assets/delete-post.gif)

```graphql
mutation deletePost($id: ID) {
    deleteComments(where: { post: { id: $id } }) {
        nodesDeleted
    }
    deletePosts(where: { id: $id }) {
        nodesDeleted
    }
}
```

## Comments

Any user can comment on any post. The Author of the comment can edit. Blog creators and post authors can delete comments on a related post.

### Type Definitions

```graphql
type Comment @timestamps {
    id: ID! @autogenerated @readonly
    author: User @relationship(type: "COMMENTED", direction: "IN") @readonly
    content: String!
    post: Post @relationship(type: "HAS_COMMENT", direction: "IN")
    canDelete: Boolean
        @cypher(
            statement: """
            OPTIONAL MATCH (this)<-[:COMMENTED]-(author:User {id: $jwt.sub})
            OPTIONAL MATCH (this)<-[:HAS_COMMENT]-(post:Post)
            OPTIONAL MATCH (post)<-[:WROTE]-(postAuthor:User {id: $jwt.sub})
            OPTIONAL MATCH (post)<-[:HAS_POST]-(blog:Blog)
            OPTIONAL MATCH (blog)<-[:HAS_BLOG]-(blogCreator:User {id: $jwt.sub})
            WITH (
                (author IS NOT NULL) OR
                (postAuthor IS NOT NULL) OR
                (blogCreator IS NOT NULL)
            ) AS canDelete
            RETURN canDelete
            """
        )
}

extend type Comment
    @auth(
        rules: [
            { operations: ["read"], isAuthenticated: false }
            { operations: ["create"], bind: { author: { id: "sub" } } }
            {
                operations: ["update", "connect"]
                allow: { author: { id: "sub" } }
                bind: { author: { id: "sub" } }
            }
            {
                operations: ["delete", "disconnect"]
                allow: {
                    OR: [
                        { author: { id: "sub" } }
                        {
                            post: {
                                OR: [
                                    { author: { id: "sub" } }
                                    { blog: { creator: { id: "sub" } } }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    )
```

### Authorization

Here some of the auth rules are explained.

#### read

```
{ operations: ["read"], isAuthenticated: false }
```

Anyone can read comments.

#### create

```
{ operations: ["create"], bind: { author: { id: "sub" } } }
```

Here we are binding the logged in `user.id` to the `author.id` field on the comment. Meaning users can only assign comments to themselves.

#### update and connect

```
{
    operations: ["update", "connect"]
    allow: { author: { id: "sub" } }
    bind: { author: { id: "sub" } }
}
```

Similar to the create above but also users can only edit there own comments & if they do they cannot change the author to someone else.

#### delete and disconnect

```
{
    operations: ["delete", "disconnect"]
    allow: {
        OR: [
            { author: { id: "sub" } }
            {
                post: {
                    OR: [
                        { author: { id: "sub" } }
                        { blog: { creator: { id: "sub" } } }
                    ]
                }
            }
        ]
    }
}
```

Here authors of the comment, authors of the post or creators of the blog can delete comments.

### Create Comment

Any user can comment on any post.

![create comment gif](assets/create-comment.gif)

> Comments support markdown

```graphql
mutation commentOnPost($post: ID, $content: String!, $user: ID) {
    commentOnPost: createComments(
        input: [
            {
                content: $content
                post: { connect: { where: { id: $post } } }
                author: { connect: { where: { id: $user } } }
            }
        ]
    ) {
        id
        content
        author {
            id
            email
        }
        createdAt
    }
}
```

### Edit Comment

Users can edit there own comments.

![edit comment gif](assets/edit-comment.gif)

```graphql
mutation updateComment($id: ID, $content: String) {
    updateComments(where: { id: $id }, update: { content: $content }) {
        id
    }
}
```

### Delete Comment

Authors of the comment, authors of the post plus creators of the blog can delete a comment.

![delete comment gif](assets/delete-comment.gif)

```graphql
mutation deleteComment($id: ID) {
    deleteComments(where: { id: $id }) {
        nodesDeleted
    }
}
```
