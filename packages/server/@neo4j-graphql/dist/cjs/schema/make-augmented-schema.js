"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var camelcase_1 = __importDefault(require("camelcase"));
var graphql_1 = require("graphql");
var graphql_compose_1 = require("graphql-compose");
var schema_1 = require("@graphql-tools/schema");
var pluralize_1 = __importDefault(require("pluralize"));
var classes_1 = require("../classes");
var get_field_type_meta_1 = __importDefault(require("./get-field-type-meta"));
var get_cypher_meta_1 = __importDefault(require("./get-cypher-meta"));
var get_auth_1 = __importDefault(require("./get-auth"));
var get_relationship_meta_1 = __importDefault(require("./get-relationship-meta"));
var utils_1 = require("../utils");
var find_1 = __importDefault(require("./find"));
var create_1 = __importDefault(require("./create"));
var delete_1 = __importDefault(require("./delete"));
var cypher_resolver_1 = __importDefault(require("./cypher-resolver"));
var update_1 = __importDefault(require("./update"));
var merge_extensions_into_ast_1 = __importDefault(require("./merge-extensions-into-ast"));
var parse_value_node_1 = __importDefault(require("./parse-value-node"));
var merge_typedefs_1 = __importDefault(require("./merge-typedefs"));
var check_node_implements_interfaces_1 = __importDefault(require("./check-node-implements-interfaces"));
var scalars_1 = require("./scalars");
var parse_exclude_directive_1 = __importDefault(require("./parse-exclude-directive"));
var graphql_arg_to_compose_1 = __importDefault(require("./graphql-arg-to-compose"));
var wrap_custom_resolvers_1 = __importDefault(require("./wrap-custom-resolvers"));
function getObjFieldMeta(_a) {
    var _b;
    var obj = _a.obj, objects = _a.objects, interfaces = _a.interfaces, scalars = _a.scalars, unions = _a.unions, enums = _a.enums;
    return (_b = obj === null || obj === void 0 ? void 0 : obj.fields) === null || _b === void 0 ? void 0 : _b.reduce(function (res, field) {
        var _a, _b, _c, _d, _e, _f;
        var privateField = (_a = field === null || field === void 0 ? void 0 : field.directives) === null || _a === void 0 ? void 0 : _a.find(function (x) { return x.name.value === "private"; });
        if (privateField) {
            return res;
        }
        var relationshipMeta = get_relationship_meta_1.default(field);
        var cypherMeta = get_cypher_meta_1.default(field);
        var typeMeta = get_field_type_meta_1.default(field);
        var authDirective = (_b = field.directives) === null || _b === void 0 ? void 0 : _b.find(function (x) { return x.name.value === "auth"; });
        var autogenerateDirective = (_c = field === null || field === void 0 ? void 0 : field.directives) === null || _c === void 0 ? void 0 : _c.find(function (x) { return x.name.value === "autogenerate"; });
        var fieldInterface = interfaces.find(function (x) { return x.name.value === typeMeta.name; });
        var fieldUnion = unions.find(function (x) { return x.name.value === typeMeta.name; });
        var fieldScalar = scalars.find(function (x) { return x.name.value === typeMeta.name; });
        var fieldEnum = enums.find(function (x) { return x.name.value === typeMeta.name; });
        var fieldObject = objects.find(function (x) { return x.name.value === typeMeta.name; });
        var baseField = __assign(__assign({ fieldName: field.name.value, typeMeta: typeMeta, otherDirectives: (field.directives || []).filter(function (x) { return !["relationship", "cypher", "autogenerate", "auth"].includes(x.name.value); }), arguments: __spread((field.arguments || [])) }, (authDirective ? { auth: get_auth_1.default(authDirective) } : {})), { description: (_d = field.description) === null || _d === void 0 ? void 0 : _d.value });
        if (relationshipMeta) {
            if (fieldInterface) {
                throw new Error("cannot have interface on relationship");
            }
            if (authDirective) {
                throw new Error("cannot have auth directive on a relationship");
            }
            var relationField = __assign(__assign({}, baseField), relationshipMeta);
            if (fieldUnion) {
                var nodes_1 = [];
                (_e = fieldUnion.types) === null || _e === void 0 ? void 0 : _e.forEach(function (type) {
                    var node = objects.find(function (x) { return x.name.value === type.name.value; });
                    if (!node) {
                        throw new Error("relationship union type " + type.name.value + " must be an object type");
                    }
                    nodes_1.push(type.name.value);
                });
                var unionField = __assign(__assign({}, baseField), { nodes: nodes_1 });
                relationField.union = unionField;
            }
            res.relationFields.push(relationField);
        }
        else if (cypherMeta) {
            var cypherField = __assign(__assign({}, baseField), cypherMeta);
            res.cypherFields.push(cypherField);
        }
        else if (fieldScalar) {
            var scalarField = __assign({}, baseField);
            res.scalarFields.push(scalarField);
        }
        else if (fieldEnum) {
            var enumField = __assign({}, baseField);
            res.enumFields.push(enumField);
        }
        else if (fieldUnion) {
            var unionField = __assign({}, baseField);
            res.unionFields.push(unionField);
        }
        else if (fieldInterface) {
            var interfaceField = __assign({}, baseField);
            res.interfaceFields.push(interfaceField);
        }
        else if (fieldObject) {
            var objectField = __assign({}, baseField);
            res.objectFields.push(objectField);
        }
        else {
            // eslint-disable-next-line no-lonely-if
            if (typeMeta.name === "DateTime") {
                var dateTimeField = __assign({}, baseField);
                if (autogenerateDirective) {
                    if (baseField.typeMeta.array) {
                        throw new Error("cannot auto-generate an array");
                    }
                    var operations = (_f = autogenerateDirective.arguments) === null || _f === void 0 ? void 0 : _f.find(function (x) { return x.name.value === "operations"; });
                    if (!operations) {
                        throw new Error("@autogenerate operations required");
                    }
                    if (operations.value.kind !== "ListValue") {
                        throw new Error("@autogenerate operations must be an array");
                    }
                    var timestamps = operations.value.values.map(function (x) {
                        return parse_value_node_1.default(x);
                    });
                    var allowedOperations_1 = ["create", "update"];
                    timestamps.forEach(function (op, i) {
                        if (!allowedOperations_1.includes(op)) {
                            throw new Error("@autogenerate operations[" + i + "] invalid");
                        }
                    });
                    dateTimeField.timestamps = timestamps;
                }
                res.dateTimeFields.push(dateTimeField);
            }
            else if (["Point", "CartesianPoint"].includes(typeMeta.name)) {
                var pointField = __assign({}, baseField);
                res.pointFields.push(pointField);
            }
            else {
                var primitiveField = __assign({}, baseField);
                if (autogenerateDirective) {
                    if (baseField.typeMeta.name !== "ID") {
                        throw new Error("cannot auto-generate a non ID field");
                    }
                    if (baseField.typeMeta.array) {
                        throw new Error("cannot auto-generate an array");
                    }
                    primitiveField.autogenerate = true;
                }
                res.primitiveFields.push(primitiveField);
            }
        }
        return res;
    }, {
        relationFields: [],
        primitiveFields: [],
        cypherFields: [],
        scalarFields: [],
        enumFields: [],
        unionFields: [],
        interfaceFields: [],
        objectFields: [],
        dateTimeFields: [],
        pointFields: [],
    });
}
function objectFieldsToComposeFields(fields) {
    return fields.reduce(function (res, field) {
        var _a;
        var newField = {
            type: field.typeMeta.pretty,
            args: {},
            description: field.description,
        };
        if (field.otherDirectives.length) {
            newField.extensions = {
                directives: field.otherDirectives.map(function (directive) {
                    var _a;
                    return ({
                        args: (_a = (directive.arguments || [])) === null || _a === void 0 ? void 0 : _a.reduce(function (r, d) {
                            var _a;
                            return (__assign(__assign({}, r), (_a = {}, _a[d.name.value] = parse_value_node_1.default(d.value), _a)));
                        }, {}),
                        name: directive.name.value,
                    });
                }),
            };
        }
        if (field.arguments) {
            newField.args = graphql_arg_to_compose_1.default(field.arguments);
        }
        return __assign(__assign({}, res), (_a = {}, _a[field.fieldName] = newField, _a));
    }, {});
}
function makeAugmentedSchema(options) {
    var document = merge_extensions_into_ast_1.default(merge_typedefs_1.default(options.typeDefs));
    var composer = new graphql_compose_1.SchemaComposer();
    var neoSchema;
    // @ts-ignore
    var neoSchemaInput = {
        options: options,
    };
    // graphql-compose will break if the Point and CartesianPoint types are created but not used,
    // because it will purge the unused types but leave behind orphaned field resolvers
    //
    // These are flags to check whether the types are used and then create them if they are
    var pointInTypeDefs = false;
    var cartesianPointInTypeDefs = false;
    composer.createObjectTC({
        name: "DeleteInfo",
        fields: {
            nodesDeleted: "Int!",
            relationshipsDeleted: "Int!",
        },
    });
    var queryOptions = composer.createInputTC({
        name: "QueryOptions",
        fields: {
            skip: "Int",
            limit: "Int",
        },
    });
    var customResolvers = (document.definitions || []).reduce(function (res, definition) {
        if (definition.kind !== "ObjectTypeDefinition") {
            return res;
        }
        if (!["Query", "Mutation", "Subscription"].includes(definition.name.value)) {
            return res;
        }
        var cypherOnes = (definition.fields || []).filter(function (field) { return field.directives && field.directives.find(function (direc) { return direc.name.value === "cypher"; }); });
        var normalOnes = (definition.fields || []).filter(function (field) {
            return (field.directives && !field.directives.find(function (direc) { return direc.name.value === "cypher"; })) ||
                !field.directives;
        });
        if (definition.name.value === "Query") {
            if (cypherOnes.length) {
                res.customCypherQuery = __assign(__assign({}, definition), { fields: cypherOnes });
            }
            if (normalOnes.length) {
                res.customQuery = __assign(__assign({}, definition), { fields: normalOnes });
            }
        }
        if (definition.name.value === "Mutation") {
            if (cypherOnes.length) {
                res.customCypherMutation = __assign(__assign({}, definition), { fields: cypherOnes });
            }
            if (normalOnes.length) {
                res.customMutation = __assign(__assign({}, definition), { fields: normalOnes });
            }
        }
        if (definition.name.value === "Subscription") {
            if (normalOnes.length) {
                res.customSubscription = __assign(__assign({}, definition), { fields: normalOnes });
            }
        }
        return res;
    }, {});
    var scalars = document.definitions.filter(function (x) { return x.kind === "ScalarTypeDefinition"; });
    var objectNodes = document.definitions.filter(function (x) { return x.kind === "ObjectTypeDefinition" && !["Query", "Mutation", "Subscription"].includes(x.name.value); });
    var enums = document.definitions.filter(function (x) { return x.kind === "EnumTypeDefinition"; });
    var inputs = document.definitions.filter(function (x) { return x.kind === "InputObjectTypeDefinition"; });
    var interfaces = document.definitions.filter(function (x) { return x.kind === "InterfaceTypeDefinition"; });
    var directives = document.definitions.filter(function (x) { return x.kind === "DirectiveDefinition"; });
    var unions = document.definitions.filter(function (x) { return x.kind === "UnionTypeDefinition"; });
    var nodes = objectNodes.map(function (definition) {
        var _a;
        check_node_implements_interfaces_1.default(definition, interfaces);
        var otherDirectives = (definition.directives || []).filter(function (x) { return !["auth", "exclude"].includes(x.name.value); });
        var authDirective = (definition.directives || []).find(function (x) { return x.name.value === "auth"; });
        var excludeDirective = (definition.directives || []).find(function (x) { return x.name.value === "exclude"; });
        var nodeInterfaces = __spread((definition.interfaces || []));
        var auth;
        if (authDirective) {
            auth = get_auth_1.default(authDirective);
        }
        var exclude;
        if (excludeDirective) {
            exclude = parse_exclude_directive_1.default(excludeDirective, definition.name.value);
        }
        var nodeFields = getObjFieldMeta({
            obj: definition,
            enums: enums,
            interfaces: interfaces,
            scalars: scalars,
            unions: unions,
            objects: objectNodes,
        });
        var node = new classes_1.Node(__assign(__assign({ name: definition.name.value, interfaces: nodeInterfaces, otherDirectives: otherDirectives }, nodeFields), { 
            // @ts-ignore
            auth: auth,
            // @ts-ignore
            exclude: exclude, description: (_a = definition.description) === null || _a === void 0 ? void 0 : _a.value }));
        return node;
    });
    var nodeNames = nodes.map(function (x) { return x.name; });
    neoSchemaInput.nodes = nodes;
    neoSchemaInput.nodes.forEach(function (node) {
        var _a, _b, _c, _d, _e;
        var _f, _g, _h, _j;
        var nodeFields = objectFieldsToComposeFields(__spread(node.primitiveFields, node.cypherFields, node.enumFields, node.scalarFields, node.interfaceFields, node.objectFields, node.unionFields, node.dateTimeFields, node.pointFields));
        var composeNode = composer.createObjectTC({
            name: node.name,
            fields: nodeFields,
            description: node.description,
            extensions: {
                directives: node.otherDirectives.map(function (directive) {
                    var _a;
                    return ({
                        args: (_a = (directive.arguments || [])) === null || _a === void 0 ? void 0 : _a.reduce(function (r, d) {
                            var _a;
                            return (__assign(__assign({}, r), (_a = {}, _a[d.name.value] = parse_value_node_1.default(d.value), _a)));
                        }, {}),
                        name: directive.name.value,
                    });
                }),
            },
            interfaces: node.interfaces.map(function (x) { return x.name.value; }),
        });
        var sortValues = __spread(node.primitiveFields, node.enumFields, node.scalarFields, node.dateTimeFields, node.pointFields).reduce(function (res, f) {
            var _a;
            return f.typeMeta.array
                ? __assign({}, res) : __assign(__assign({}, res), (_a = {}, _a[f.fieldName + "_DESC"] = { value: f.fieldName + "_DESC" }, _a[f.fieldName + "_ASC"] = { value: f.fieldName + "_ASC" }, _a));
        }, {});
        if (Object.keys(sortValues).length) {
            var sortEnum = composer.createEnumTC({
                name: node.name + "Sort",
                values: sortValues,
            });
            composer.createInputTC({
                name: node.name + "Options",
                fields: { sort: sortEnum.List, limit: "Int", skip: "Int" },
            });
        }
        else {
            composer.createInputTC({
                name: node.name + "Options",
                fields: { limit: "Int", skip: "Int" },
            });
        }
        var queryFields = __assign(__assign({ OR: "[" + node.name + "OR]", AND: "[" + node.name + "AND]" }, node.scalarFields.reduce(function (res, f) {
            res[f.fieldName] = f.typeMeta.array ? "[" + f.typeMeta.name + "]" : f.typeMeta.name;
            return res;
        }, {})), __spread(node.primitiveFields, node.dateTimeFields, node.enumFields, node.pointFields).reduce(function (res, f) {
            // This is the only sensible place to flag whether Point and CartesianPoint are used
            if (f.typeMeta.name === "Point") {
                pointInTypeDefs = true;
            }
            else if (f.typeMeta.name === "CartesianPoint") {
                cartesianPointInTypeDefs = true;
            }
            res[f.fieldName] = f.typeMeta.input.pretty;
            res[f.fieldName + "_NOT"] = f.typeMeta.input.pretty;
            if (f.typeMeta.name !== "Boolean") {
                res[f.fieldName + "_IN"] = f.typeMeta.array
                    ? f.typeMeta.input.name
                    : "[" + f.typeMeta.input.name + "]";
                res[f.fieldName + "_NOT_IN"] = f.typeMeta.array
                    ? f.typeMeta.input.name
                    : "[" + f.typeMeta.input.name + "]";
            }
            if (!f.typeMeta.array) {
                if (["Float", "Int", "DateTime"].includes(f.typeMeta.name)) {
                    ["_LT", "_LTE", "_GT", "_GTE"].forEach(function (comparator) {
                        res["" + f.fieldName + comparator] = f.typeMeta.name;
                    });
                }
                if (["Point", "CartesianPoint"].includes(f.typeMeta.name)) {
                    ["_DISTANCE", "_LT", "_LTE", "_GT", "_GTE"].forEach(function (comparator) {
                        res["" + f.fieldName + comparator] = f.typeMeta.name + "Distance";
                    });
                }
                if (["String", "ID"].includes(f.typeMeta.name)) {
                    res[f.fieldName + "_REGEX"] = "String";
                    [
                        "_CONTAINS",
                        "_NOT_CONTAINS",
                        "_STARTS_WITH",
                        "_NOT_STARTS_WITH",
                        "_ENDS_WITH",
                        "_NOT_ENDS_WITH",
                    ].forEach(function (comparator) {
                        res["" + f.fieldName + comparator] = f.typeMeta.name;
                    });
                }
            }
            return res;
        }, {}));
        var _k = __read(["AND", "OR", "Where"].map(function (value) {
            return composer.createInputTC({
                name: "" + node.name + value,
                fields: queryFields,
            });
        }), 3), andInput = _k[0], orInput = _k[1], whereInput = _k[2];
        var nodeInput = composer.createInputTC({
            name: node.name + "CreateInput",
            fields: __spread(node.primitiveFields, node.scalarFields, node.enumFields, node.dateTimeFields.filter(function (x) { return !x.timestamps; }), node.pointFields).reduce(function (res, f) {
                var _a;
                if ((_a = f) === null || _a === void 0 ? void 0 : _a.autogenerate) {
                    var field = {
                        type: f.typeMeta.name,
                        defaultValue: "autogenerate",
                    };
                    res[f.fieldName] = field;
                }
                else {
                    var field = {
                        type: f.typeMeta.pretty,
                    };
                    res[f.fieldName] = f.typeMeta.input.pretty;
                }
                return res;
            }, {}),
        });
        var nodeUpdateInput = composer.createInputTC({
            name: node.name + "UpdateInput",
            fields: __spread(node.primitiveFields, node.scalarFields, node.enumFields, node.dateTimeFields.filter(function (x) { return !x.timestamps; }), node.pointFields).reduce(function (res, f) {
                var _a;
                return (__assign(__assign({}, res), (_a = {}, _a[f.fieldName] = f.typeMeta.input.pretty, _a)));
            }, {}),
        });
        var nodeDeleteInput = composer.createInputTC({
            name: node.name + "DeleteInput",
            fields: {},
        });
        ["Create", "Update"].map(function (operation) {
            var _a;
            return composer.createObjectTC({
                name: "" + operation + pluralize_1.default(node.name) + "MutationResponse",
                fields: (_a = {},
                    _a[pluralize_1.default(camelcase_1.default(node.name))] = "[" + node.name + "!]!",
                    _a),
            });
        });
        var nodeConnectInput = undefined;
        var nodeDisconnectInput = undefined;
        var nodeRelationInput = undefined;
        if (node.relationFields.length) {
            _a = __read([
                "ConnectInput",
                "DisconnectInput",
                "RelationInput",
            ].map(function (type) {
                return composer.createInputTC({
                    name: "" + node.name + type,
                    fields: {},
                });
            }), 3), nodeConnectInput = _a[0], nodeDisconnectInput = _a[1], nodeRelationInput = _a[2];
        }
        composer.createInputTC({
            name: node.name + "ConnectFieldInput",
            fields: __assign({ where: node.name + "Where" }, (node.relationFields.length ? { connect: nodeConnectInput } : {})),
        });
        composer.createInputTC({
            name: node.name + "DisconnectFieldInput",
            fields: __assign({ where: node.name + "Where" }, (node.relationFields.length ? { disconnect: nodeDisconnectInput } : {})),
        });
        composer.createInputTC({
            name: node.name + "DeleteFieldInput",
            fields: __assign({ where: node.name + "Where" }, (node.relationFields.length ? { delete: nodeDeleteInput } : {})),
        });
        node.relationFields.forEach(function (rel) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (rel.union) {
                var refNodes = neoSchemaInput.nodes.filter(function (x) { var _a, _b; return (_b = (_a = rel.union) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b.includes(x.name); });
                composeNode.addFields((_a = {},
                    _a[rel.fieldName] = {
                        type: rel.typeMeta.pretty,
                        args: {
                            options: queryOptions.getTypeName(),
                        },
                    },
                    _a));
                refNodes.forEach(function (n) {
                    var _a, _b, _c, _d, _e, _f, _g;
                    var concatFieldName = rel.fieldName + "_" + n.name;
                    var createField = rel.typeMeta.array ? "[" + n.name + "CreateInput]" : n.name + "CreateInput";
                    var updateField = n.name + "UpdateInput";
                    var nodeFieldInputName = "" + node.name + utils_1.upperFirstLetter(rel.fieldName) + n.name + "FieldInput";
                    var nodeFieldUpdateInputName = "" + node.name + utils_1.upperFirstLetter(rel.fieldName) + n.name + "UpdateFieldInput";
                    var nodeFieldDeleteInputName = "" + node.name + utils_1.upperFirstLetter(rel.fieldName) + n.name + "DeleteInput";
                    var connectField = rel.typeMeta.array
                        ? "[" + n.name + "ConnectFieldInput]"
                        : n.name + "ConnectFieldInput";
                    var disconnectField = rel.typeMeta.array
                        ? "[" + n.name + "DisconnectFieldInput]"
                        : n.name + "DisconnectFieldInput";
                    var deleteField = rel.typeMeta.array
                        ? "[" + n.name + "DeleteFieldInput]"
                        : n.name + "DeleteFieldInput";
                    composeNode.addFieldArgs(rel.fieldName, (_a = {},
                        _a[n.name] = n.name + "Where",
                        _a));
                    composer.createInputTC({
                        name: nodeFieldUpdateInputName,
                        fields: {
                            where: n.name + "Where",
                            update: updateField,
                            connect: connectField,
                            disconnect: disconnectField,
                            create: createField,
                            delete: deleteField,
                        },
                    });
                    composer.createInputTC({
                        name: nodeFieldInputName,
                        fields: {
                            create: createField,
                            connect: connectField,
                        },
                    });
                    composer.createInputTC({
                        name: nodeFieldDeleteInputName,
                        fields: __assign({ where: n.name + "Where" }, (n.relationFields.length
                            ? {
                                delete: n.name + "DeleteInput",
                            }
                            : {})),
                    });
                    nodeRelationInput.addFields((_b = {},
                        _b[concatFieldName] = createField,
                        _b));
                    nodeInput.addFields((_c = {},
                        _c[concatFieldName] = nodeFieldInputName,
                        _c));
                    nodeUpdateInput.addFields((_d = {},
                        _d[concatFieldName] = rel.typeMeta.array
                            ? "[" + nodeFieldUpdateInputName + "]"
                            : nodeFieldUpdateInputName,
                        _d));
                    nodeDeleteInput.addFields((_e = {},
                        _e[concatFieldName] = rel.typeMeta.array
                            ? "[" + nodeFieldDeleteInputName + "]"
                            : nodeFieldDeleteInputName,
                        _e));
                    nodeConnectInput.addFields((_f = {},
                        _f[concatFieldName] = connectField,
                        _f));
                    nodeDisconnectInput.addFields((_g = {},
                        _g[concatFieldName] = disconnectField,
                        _g));
                });
                return;
            }
            var n = neoSchemaInput.nodes.find(function (x) { return x.name === rel.typeMeta.name; });
            var createField = rel.typeMeta.array ? "[" + n.name + "CreateInput]" : n.name + "CreateInput";
            var updateField = n.name + "UpdateInput";
            var nodeFieldInputName = "" + node.name + utils_1.upperFirstLetter(rel.fieldName) + "FieldInput";
            var nodeFieldUpdateInputName = "" + node.name + utils_1.upperFirstLetter(rel.fieldName) + "UpdateFieldInput";
            var nodeFieldDeleteInputName = "" + node.name + utils_1.upperFirstLetter(rel.fieldName) + "DeleteInput";
            var connectField = rel.typeMeta.array ? "[" + n.name + "ConnectFieldInput]" : n.name + "ConnectFieldInput";
            var disconnectField = rel.typeMeta.array
                ? "[" + n.name + "DisconnectFieldInput]"
                : n.name + "DisconnectFieldInput";
            var deleteField = rel.typeMeta.array ? "[" + n.name + "DeleteFieldInput]" : n.name + "DeleteFieldInput";
            [whereInput, andInput, orInput].forEach(function (inputType) {
                var _a;
                inputType.addFields((_a = {},
                    _a[rel.fieldName] = n.name + "Where",
                    _a[rel.fieldName + "_NOT"] = n.name + "Where",
                    _a[rel.fieldName + "_IN"] = "[" + n.name + "Where]",
                    _a[rel.fieldName + "_NOT_IN"] = "[" + n.name + "Where]",
                    _a));
            });
            composeNode.addFields((_b = {},
                _b[rel.fieldName] = {
                    type: rel.typeMeta.pretty,
                    args: {
                        where: rel.typeMeta.name + "Where",
                        options: rel.typeMeta.name + "Options",
                    },
                },
                _b));
            composer.createInputTC({
                name: nodeFieldUpdateInputName,
                fields: {
                    where: n.name + "Where",
                    update: updateField,
                    connect: connectField,
                    disconnect: disconnectField,
                    create: createField,
                    delete: deleteField,
                },
            });
            composer.createInputTC({
                name: nodeFieldInputName,
                fields: {
                    create: createField,
                    connect: connectField,
                },
            });
            composer.createInputTC({
                name: nodeFieldDeleteInputName,
                fields: __assign({ where: n.name + "Where" }, (n.relationFields.length
                    ? {
                        delete: n.name + "DeleteInput",
                    }
                    : {})),
            });
            nodeRelationInput.addFields((_c = {},
                _c[rel.fieldName] = createField,
                _c));
            nodeInput.addFields((_d = {},
                _d[rel.fieldName] = nodeFieldInputName,
                _d));
            nodeUpdateInput.addFields((_e = {},
                _e[rel.fieldName] = rel.typeMeta.array ? "[" + nodeFieldUpdateInputName + "]" : nodeFieldUpdateInputName,
                _e));
            nodeDeleteInput.addFields((_f = {},
                _f[rel.fieldName] = rel.typeMeta.array ? "[" + nodeFieldDeleteInputName + "]" : nodeFieldDeleteInputName,
                _f));
            nodeConnectInput.addFields((_g = {},
                _g[rel.fieldName] = connectField,
                _g));
            nodeDisconnectInput.addFields((_h = {},
                _h[rel.fieldName] = disconnectField,
                _h));
        });
        if (!((_f = node.exclude) === null || _f === void 0 ? void 0 : _f.operations.includes("read"))) {
            composer.Query.addFields((_b = {},
                _b[pluralize_1.default(camelcase_1.default(node.name))] = find_1.default({ node: node, getSchema: function () { return neoSchema; } }),
                _b));
        }
        if (!((_g = node.exclude) === null || _g === void 0 ? void 0 : _g.operations.includes("create"))) {
            composer.Mutation.addFields((_c = {},
                _c["create" + pluralize_1.default(node.name)] = create_1.default({ node: node, getSchema: function () { return neoSchema; } }),
                _c));
        }
        if (!((_h = node.exclude) === null || _h === void 0 ? void 0 : _h.operations.includes("delete"))) {
            composer.Mutation.addFields((_d = {},
                _d["delete" + pluralize_1.default(node.name)] = delete_1.default({ node: node, getSchema: function () { return neoSchema; } }),
                _d));
        }
        if (!((_j = node.exclude) === null || _j === void 0 ? void 0 : _j.operations.includes("update"))) {
            composer.Mutation.addFields((_e = {},
                _e["update" + pluralize_1.default(node.name)] = update_1.default({ node: node, getSchema: function () { return neoSchema; } }),
                _e));
        }
    });
    ["Mutation", "Query"].forEach(function (type) {
        var objectComposer = composer[type];
        var cypherType = customResolvers["customCypher" + type];
        if (cypherType) {
            var objectFields = getObjFieldMeta({
                obj: cypherType,
                scalars: scalars,
                enums: enums,
                interfaces: interfaces,
                unions: unions,
                objects: objectNodes,
            });
            var objectComposeFields = objectFieldsToComposeFields(__spread(objectFields.enumFields, objectFields.interfaceFields, objectFields.primitiveFields, objectFields.relationFields, objectFields.scalarFields, objectFields.unionFields, objectFields.objectFields, objectFields.dateTimeFields));
            objectComposer.addFields(objectComposeFields);
            objectFields.cypherFields.forEach(function (field) {
                var _a;
                var customResolver = cypher_resolver_1.default({
                    field: field,
                    statement: field.statement,
                    getSchema: function () { return neoSchema; },
                });
                var composedField = objectFieldsToComposeFields([field])[field.fieldName];
                objectComposer.addFields((_a = {}, _a[field.fieldName] = __assign(__assign({}, composedField), customResolver), _a));
            });
        }
    });
    var extraDefinitions = __spread(enums, scalars, directives, inputs, unions, [
        customResolvers.customQuery,
        customResolvers.customMutation,
        customResolvers.customSubscription,
    ]).filter(Boolean);
    if (extraDefinitions.length) {
        composer.addTypeDefs(graphql_1.print({ kind: "Document", definitions: extraDefinitions }));
    }
    interfaces.forEach(function (inter) {
        var objectFields = getObjFieldMeta({ obj: inter, scalars: scalars, enums: enums, interfaces: interfaces, unions: unions, objects: objectNodes });
        var objectComposeFields = objectFieldsToComposeFields(Object.values(objectFields).reduce(function (acc, x) { return __spread(acc, x); }, []));
        composer.createInterfaceTC({
            name: inter.name.value,
            fields: objectComposeFields,
            extensions: {
                directives: (inter.directives || [])
                    .filter(function (x) { return x.name.value !== "auth"; })
                    .map(function (directive) {
                    var _a;
                    return ({
                        args: (_a = (directive.arguments || [])) === null || _a === void 0 ? void 0 : _a.reduce(function (r, d) {
                            var _a;
                            return (__assign(__assign({}, r), (_a = {}, _a[d.name.value] = parse_value_node_1.default(d.value), _a)));
                        }, {}),
                        name: directive.name.value,
                    });
                }),
            },
        });
    });
    composer.addTypeDefs("scalar Int");
    composer.addTypeDefs("scalar Float");
    composer.addTypeDefs("scalar ID");
    composer.addTypeDefs("scalar DateTime");
    if (pointInTypeDefs) {
        // Every field (apart from CRS) in Point needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC({
            name: "Point",
            fields: {
                longitude: {
                    type: "Float!",
                    resolve: function (source) {
                        return source.point.x;
                    },
                },
                latitude: {
                    type: "Float!",
                    resolve: function (source) {
                        return source.point.y;
                    },
                },
                height: {
                    type: "Float",
                    resolve: function (source) {
                        return source.point.z;
                    },
                },
                crs: "String!",
                srid: {
                    type: "Int!",
                    resolve: function (source) {
                        return source.point.srid;
                    },
                },
            },
        });
        composer.createInputTC({
            name: "PointInput",
            fields: {
                longitude: "Float!",
                latitude: "Float!",
                height: "Float",
            },
        });
        composer.createInputTC({
            name: "PointDistance",
            fields: {
                point: "PointInput!",
                distance: {
                    type: "Float!",
                    description: "The distance in metres to be used when comparing two points",
                },
            },
        });
    }
    if (cartesianPointInTypeDefs) {
        // Every field (apart from CRS) in CartesianPoint needs a custom resolver
        // to deconstruct the point objects we fetch from the database
        composer.createObjectTC({
            name: "CartesianPoint",
            fields: {
                x: {
                    type: "Float!",
                    resolve: function (source) {
                        return source.point.x;
                    },
                },
                y: {
                    type: "Float!",
                    resolve: function (source) {
                        return source.point.y;
                    },
                },
                z: {
                    type: "Float",
                    resolve: function (source) {
                        return source.point.z;
                    },
                },
                crs: "String!",
                srid: {
                    type: "Int!",
                    resolve: function (source) {
                        return source.point.srid;
                    },
                },
            },
        });
        composer.createInputTC({
            name: "CartesianPointInput",
            fields: {
                x: "Float!",
                y: "Float!",
                z: "Float",
            },
        });
        composer.createInputTC({
            name: "CartesianPointDistance",
            fields: {
                point: "CartesianPointInput!",
                distance: "Float!",
            },
        });
    }
    var generatedTypeDefs = composer.toSDL();
    var generatedResolvers = __assign(__assign(__assign(__assign(__assign({}, composer.getResolveMethods()), (generatedTypeDefs.includes("scalar Int") ? { Int: scalars_1.Int } : {})), (generatedTypeDefs.includes("scalar Float") ? { Float: scalars_1.Float } : {})), (generatedTypeDefs.includes("scalar ID") ? { ID: scalars_1.ID } : {})), (generatedTypeDefs.includes("scalar DateTime") ? { DateTime: scalars_1.DateTime } : {}));
    if (options.resolvers) {
        generatedResolvers = wrap_custom_resolvers_1.default({
            generatedResolvers: generatedResolvers,
            getNeoSchema: function () { return neoSchema; },
            nodeNames: nodeNames,
            resolvers: options.resolvers,
        });
    }
    unions.forEach(function (union) {
        generatedResolvers[union.name.value] = { __resolveType: function (root) { return root.__resolveType; } };
    });
    neoSchemaInput.typeDefs = generatedTypeDefs;
    neoSchemaInput.resolvers = generatedResolvers;
    neoSchemaInput.schema = schema_1.makeExecutableSchema({
        typeDefs: generatedTypeDefs,
        resolvers: generatedResolvers,
        schemaDirectives: options.schemaDirectives,
    });
    neoSchema = new classes_1.NeoSchema(neoSchemaInput);
    return neoSchema;
}
exports.default = makeAugmentedSchema;
//# sourceMappingURL=make-augmented-schema.js.map